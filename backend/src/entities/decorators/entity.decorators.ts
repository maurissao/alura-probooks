import 'reflect-metadata';
import { ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments } from 'class-validator';
import { FormaPagamento, IEntity } from '../types';

export const Column = function(propertyType?: any|any[]) {
  return function (target: any, propertyKey: string | symbol) {
    const entityColumn = Reflect.getMetadata('EntityColumn', target.constructor) || [];
    entityColumn.push({
      propertyKey,
      propertyType
    });
    Reflect.defineMetadata('EntityColumn', entityColumn, target.constructor);
  }
}

export const CheckFK = function (table: string, key: string) {
  return function (target: any, propertyKey: string | symbol) {
    const cc: any[] = Reflect.getMetadata('CheckConstraintFK', target.constructor) || [];
    cc.push({ columnName: propertyKey, fkTable: table, fkColumnName: key });
    Reflect.defineMetadata('CheckConstraintFK', cc, target.constructor);
  };
};

export const IsAutoGeneratedID = function () {
  return function (target: any, propertyKey: string | symbol) {
    Reflect.defineMetadata('AutoGeneratedID', propertyKey, target.constructor, propertyKey);
  };
};

export const IsUnique = function () {
  return function (target: any, propertyKey: string | symbol) {
    Reflect.defineMetadata('IsUnique', true, target.constructor, propertyKey);
  }
}

@ValidatorConstraint()
export class ValidateCPF implements ValidatorConstraintInterface {
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    if (value) {
      let cpf = value as string;
      cpf = cpf.replace(/[.\-\s]/g, '');
      const pattern =  /^\d{11}$/;
      return pattern.test(cpf);
    } else
      return false;
  }

  defaultMessage(validationArguments?: ValidationArguments): string {
    return 'CPF inválido';
  }
}

@ValidatorConstraint()
export class ValidateTelefone implements ValidatorConstraintInterface {
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    if (value) {
      console.log(validationArguments.object);
      let phone: string = value as string;
      phone = phone.replace(/\D/g, "");
      const patternFixo = /^\d{2}9?\d{8}$/;
      const patternMovel = /^\d{2}9\d{8}$/;
      return patternFixo.test(phone) || patternMovel.test(phone);
    } else
      return false;
  }

  defaultMessage(validationArguments?: ValidationArguments): string {
    return 'Telefone inválido';
  }
}

@ValidatorConstraint()
export class ValidateParcelas implements ValidatorConstraintInterface {
  private _message: string;
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    const entity = validationArguments.object;
    const parcelas = value as number;
    const formaPagamento = entity['formaPagamento'] as FormaPagamento;
    if (formaPagamento) {
      if (formaPagamento === FormaPagamento.DEBITO && parcelas != 1) {
        this._message = 'A parcela deve ser 1 para essa forma de pagamento';
        return false;
      } else {
        if (formaPagamento === FormaPagamento.CREDITO && parcelas > 12) {
          this._message = 'Parcelamento a crédito não pode exceder 12 parcelas';
          return false;
        }
      }
    }
    return true;
  }

  defaultMessage(validationArguments?: ValidationArguments): string {
    return this._message || 'Parcela inválida';
  }
}
