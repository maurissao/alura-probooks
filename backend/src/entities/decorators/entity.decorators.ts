import 'reflect-metadata';
import { ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments, ValidationOptions } from 'class-validator';
import { IEntity, Entity } from '../types';

export const IsNotEmptyMessage: ValidationOptions = {
  message: (args: ValidationArguments) => {
    return `${args.property} não pode estar vazio`
  }
}

export const MinLengthMessage: ValidationOptions = {
  message: (args: ValidationArguments) => {
    return `${args.property} precisa ter no mínimo ${args.constraints[0]} caracteres`
  }
}

export const IsValidMessage: ValidationOptions = {
  message: (args: ValidationArguments) => {
    return `${args.property} inválido`
  }
}

export const LengthMessage: ValidationOptions = {
  message: (args: ValidationArguments) => {
    return `${args.property} precisa ter no mínimo ${args.constraints[0]} caracteres`
  }
}

export const Column = function(propertyType?: any|any[]) {
  return function (target: any, propertyKey: string | symbol) {
    const entityColumn = Reflect.getMetadata('EntityColumn', target.constructor) || [];
    entityColumn.push({
      propertyKey,
      propertyType
    });
    Reflect.defineMetadata('EntityColumn', entityColumn, target.constructor);
  }
}

export const CheckFK = function (table: string, key: string) {
  return function (target: any, propertyKey: string | symbol) {
    const cc: any[] = Reflect.getMetadata('CheckConstraintFK', target.constructor) || [];
    cc.push({ columnName: propertyKey, fkTable: table, fkColumnName: key });
    Reflect.defineMetadata('CheckConstraintFK', cc, target.constructor);
  };
};

@ValidatorConstraint()
export class ValidateConstraintFK implements ValidatorConstraintInterface {
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    
    //const repository = Store.Instance.getRepository<validationArguments.object as Entity>();
    return false;
  }
  defaultMessage(validationArguments?: ValidationArguments): string {
    return '';
  }
}

export const IsAutoGeneratedID = function () {
  return function (target: any, propertyKey: string | symbol) {
    Reflect.defineMetadata('AutoGeneratedID', propertyKey, target.constructor, propertyKey);
  };
};

export const IsUnique = function () {
  return function (target: any, propertyKey: string | symbol) {
    Reflect.defineMetadata('IsUnique', true, target.constructor, propertyKey);
  }
}

@ValidatorConstraint()
export class ValidateCPF implements ValidatorConstraintInterface {
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    if (value) {
      let cpf = value as string;
      cpf = cpf.replace(/[.\-\s]/g, '');
      const pattern =  /^\d{11}$/;
      return pattern.test(cpf);
    } else
      return false;
  }

  defaultMessage(validationArguments?: ValidationArguments): string {
    return `O valor informado para: ${validationArguments.property} em ${validationArguments.targetName} não é válido`;
  }
}

@ValidatorConstraint()
export class ValidateTelefone implements ValidatorConstraintInterface {
  validate(value: any, validationArguments?: ValidationArguments): boolean | Promise<boolean> {
    if (value) {
      let phone: string = value as string;
      phone = phone.replace(/\D/g, "");
      const patternFixo = /^\d{2}9?\d{8}$/;
      const patternMovel = /^\d{2}9\d{8}$/;
      return patternFixo.test(phone) || patternMovel.test(phone);
    } else
      return false;
  }

  defaultMessage(validationArguments?: ValidationArguments): string {
    return `O valor informado para: ${validationArguments.property} em ${validationArguments.targetName} não é válido`;
  }
}
