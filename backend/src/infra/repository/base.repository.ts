import { IEntity } from '../../entities/types';
import { Store } from "../database/store";
import { ValidationError, validate } from "class-validator";
import { v4 as uuid  } from "uuid";
import "reflect-metadata";

export class Repository<T extends IEntity> {
  #store: Store;
  #entityColumns: any[];

  constructor(private entity: any) {
    this.#store = Store.Instance;
    this.#entityColumns = Reflect.getOwnMetadata('EntityColumn', this.entity);
  }

  private processDecorators(entity: T): void {
    let propertyKey: string;
    let metadata: any;
    metadata = Reflect.getMetadata('CheckConstraintFK', entity.constructor);
    if (metadata) {
      for (let checkFK of metadata) {
        const columnName = checkFK['columnName'];
        const fkTable = checkFK['fkTable'];
        const fkColumnName = checkFK['fkColumnName'];
        const data = this.#store.getData(fkTable);
        if (data.filter(v => { return v[fkColumnName] === entity[columnName] }).length <= 0)
          throw new Error(`Chave não encontrada ${columnName} ${entity[columnName]}`);
      }
    }
    this.#entityColumns.map(e => {
      metadata = Reflect.getMetadata('AutoGeneratedID', entity.constructor, e.propertyKey);
      if (metadata) 
        entity[e.propertyKey] = uuid();

      metadata = Reflect.getMetadata('IsUnique', entity.constructor, e.propertyKey);
      if (metadata) {
        const data = this.#store.getData(entity.constructor.name) || [];
        if (data.length > 0 && data.filter(v => { return v[e.propertyKey] === entity[e.propertyKey] }).length > 0)
          throw new Error(`Erro de violação de registro único: já existe um registro com ${e.propertyKey} ${entity[e.propertyKey]}`);
      }
    });
    
    
  }

  private async validateSchema(Model: T): Promise<boolean> {
    let errorMessage: string = '';
    const erros: ValidationError[] = await validate(Model);
    erros.map(v => errorMessage += Object.values(v.constraints)[0] + '\n');
    if (errorMessage != '') 
        throw new Error('Inclusão de dados não passou pela validação:\n' + errorMessage);
    return true;
  }

  async insert(dto: Object): Promise<T> {
    const entity = new this.entity;
    this.#entityColumns.map(c => {
      if (c.propetyType === Date)
        entity[c.propertyKey] = new Date(dto[c.propertyKey])
      else
        entity[c.propertyKey] = dto[c.propertyKey];
    });

    this.processDecorators(entity);
    if (await this.validateSchema(entity)) {
      this.#store.saveData(entity.constructor.name, entity);
      return entity;
    } else
      return null
  }

  getAll(): T[] {
    const data: any[] = this.#store.getData((new this.entity).constructor.name);
    return data;
  }

  findeOne(id: any): T {
    const data: T[] = this.#store.getData((new this.entity).constructor.name);
    const retorno = data.filter((e) => e['id'] === id);
    console.log(retorno[0]);
    return retorno[0];
  }
}
